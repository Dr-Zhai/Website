<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8"/>
        <title>单机五子棋</title>
        <style>
            body {
                font-family: "Microsoft YaHei", "微软雅黑", sans-serif;
            }

            canvas {
                display: block;
                margin: 20px auto;
                box-shadow: -2px -2px 2px #efefef, 5px 5px 5px #b9b9b9;
                cursor: pointer;
            }

            .board-select {
                text-align: center;
                margin: 20px 0;
            }

            .board-select span {
                display: inline-block;
                padding: 8px 16px;
                margin: 0 5px;
                background: #4CAF50;
                color: #fff;
                border-radius: 4px;
                cursor: pointer;
            }

            .board-select span.active {
                background: skyblue;
            }

            .stats {
                text-align: center;
                margin: 10px 0;
                font-size: 16px;
                color: #333;
            }

            .btn-wrap {
                display: flex;
                justify-content: center;
                margin: 10px 0;
            }

            .btn-wrap div {
                margin: 0 10px;
            }

            div > span {
                display: inline-block;
                padding: 10px 20px;
                color: #fff;
                background: #4CAF50;
                border-radius: 5px;
                cursor: pointer;
            }

            div.unable span {
                background: #A9A9A9;
                color: #666;
                cursor: not-allowed;
            }

            #result-wrap {
                text-align: center;
                margin: 30px 0;
            }

            .copyright {
                text-align: center;
                margin: 30px 0;
                color: #666;
                font-size: 14px;
            }
        </style>
    </head>
    <body>
        <h1 id="result-wrap">单机五子棋</h1>
        <div class="board-select">
            <b>棋盘大小：</b>
            <span class="board-size" data-size="15">标准棋盘(15x15)</span>
            <span class="board-size" data-size="30">超大棋盘(30x30)</span>
        </div>
        <div class="stats">
            <div>本局已悔棋：<b id="regretCount">0</b>次</div>
            <div>本局已输棋：<b id="loseCount">0</b>次</div>
        </div>
        <canvas height="450" id="chess" width="450"></canvas>
        <div class="btn-wrap">
            <div class="restart" id='restart'><span>重新开始</span></div>
            <div class="goback unable" id='goback'><span>悔棋</span></div>
            <div class="return unable" id='return'><span>撤销</span></div>
            <div class="sponsor" id='sponsor'><span>赞助支持</span></div>
        </div>
        <footer class="copyright">© <span id="currentYear"></span> 宅博士. 版权所有.</footer>

        <script>
            // 1. 缓存DOM元素（减少重复查询）
            const DOM = {
                chess: document.getElementById('chess'),
                resultWrap: document.getElementById('result-wrap'),
                restartBtn: document.getElementById('restart'),
                backBtn: document.getElementById('goback'),
                returnBtn: document.getElementById('return'),
                sponsorBtn: document.getElementById('sponsor'),
                regretCount: document.getElementById('regretCount'),
                loseCount: document.getElementById('loseCount'),
                currentYear: document.getElementById('currentYear'),
                boardSizes: document.querySelectorAll('.board-size')
            };
            const ctx = DOM.chess.getContext('2d');

            // 2. 集中声明状态变量
            const state = {
                over: false,
                isPlayerTurn: true, // 原me
                playerMove: null,
                computerMove: null,
                moveHistory: null,
                canBack: false,
                canReturn: false,
                boardSize: 15,
                chessBoard: [],
                myWin: [],
                computerWin: [],
                wins: [],
                winCount: 0,
                regretCount: 0,
                loseCount: 0,
                hasCountLose: false,
                lastPlayerChess: null,
                lastCompChess: null,
                winLine: [],
                winColor: null,
                winner: null,
                isCompWinRegret: false
            };

            // 初始化年份
            DOM.currentYear.textContent = new Date().getFullYear();

            // 页面加载初始化
            window.onload = () => {
                initBoard();
                drawChessBoard();
                bindEvents();
                updateBtnStates();
                DOM.boardSizes.forEach(btn => btn.dataset.size === '15' && btn.classList.add('active'));
            };

            // 3. 简化按钮状态更新
            function updateBtnStates() {
                DOM.backBtn.classList.toggle('unable', !state.canBack);
                DOM.returnBtn.classList.toggle('unable', !state.canReturn);
            }

            // 4. 整合事件绑定
            function bindEvents() {
                // 棋盘大小选择
                DOM.boardSizes.forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (state.winner || state.over) return;
                        DOM.boardSizes.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        state.boardSize = parseInt(btn.dataset.size);
                        DOM.chess.width = DOM.chess.height = state.boardSize * 30;
                        initBoard();
                        drawChessBoard();
                        resetGameState();
                    });
                });

                // 功能按钮绑定
                DOM.sponsorBtn.onclick = () => window.open("payment/pay.html", "_blank");
                DOM.restartBtn.onclick = resetGameState;

                // 玩家落子
                DOM.chess.onclick = e => {
                    if (!state.isPlayerTurn || state.over || state.winner) return;

                    const rect = DOM.chess.getBoundingClientRect();
                    const i = Math.floor((e.clientX - rect.left) / 30);
                    const j = Math.floor((e.clientY - rect.top) / 30);
                    if (i < 0 || i >= state.boardSize || j < 0 || j >= state.boardSize || state.chessBoard[i][j] !== 0) return;

                    // 清除上一玩家棋子标记
                    state.lastPlayerChess && redrawPiece(...state.lastPlayerChess, true, false);
                    // 记录并落子
                    state.playerMove = {i, j};
                    state.chessBoard[i][j] = 1;
                    redrawPiece(i, j, true, true);
                    state.lastPlayerChess = [i, j];

                    // 备份赢法状态
                    const preMyWin = [...state.myWin];
                    const preCompWin = [...state.computerWin];

                    // 检查玩家胜利
                    if (checkWin(i, j, true)) {
                        DOM.resultWrap.innerHTML = '很厉害，你赢了！';
                        state.over = true;
                        state.winner = 'player';
                        state.canBack = state.canReturn = false;
                        updateBtnStates();
                        return;
                    }

                    // 检查和棋
                    if (checkDraw()) {
                        DOM.resultWrap.innerHTML = '棋盘已满，和棋！';
                        state.over = true;
                        state.winner = 'draw';
                        state.canBack = state.canReturn = false;
                        updateBtnStates();
                        return;
                    }

                    // 切换回合并调用AI
                    state.isPlayerTurn = false;
                    computerAI();

                    // 保存历史记录
                    if (state.computerMove) {
                        state.moveHistory = {preMyWin, preCompWin, ...state};
                        state.canBack = true;
                        state.canReturn = false;
                        updateBtnStates();
                    }
                };

                // 悔棋逻辑
                DOM.backBtn.onclick = () => {
                    if (state.winner === 'player' || !state.canBack || !state.moveHistory) return;

                    state.isCompWinRegret = state.winner === 'computer';
                    DOM.regretCount.textContent = ++state.regretCount;

                    // 输棋计数
                    if (state.winner === 'computer' && !state.hasCountLose) {
                        DOM.loseCount.textContent = ++state.loseCount;
                        state.hasCountLose = true;
                    }

                    // 重置基础状态
                    Object.assign(state, {
                        over: false,
                        isPlayerTurn: true,
                        winner: null,
                        winLine: [],
                        winColor: null,
                        canReturn: !state.isCompWinRegret,
                        canBack: false
                    });
                    updateBtnStates();

                    // 恢复棋盘与赢法状态
                    const {preMyWin, preCompWin, playerMove, computerMove} = state.moveHistory;
                    state.chessBoard[playerMove.i][playerMove.j] = 0;
                    state.chessBoard[computerMove.i][computerMove.j] = 0;
                    state.myWin = [...preMyWin];
                    state.computerWin = [...preCompWin];

                    // 重绘棋盘
                    drawChessBoard();
                    updateLatestPieces();
                    redrawAllPieces();
                    DOM.resultWrap.innerHTML = '单机五子棋';
                };

                // 撤销悔棋逻辑
                DOM.returnBtn.onclick = () => {
                    if (!state.canReturn || state.isCompWinRegret || state.winner === 'player' || !state.moveHistory) return;

                    // 清除悔棋后标记
                    state.lastPlayerChess && redrawPiece(...state.lastPlayerChess, true, false);
                    state.lastCompChess && redrawPiece(...state.lastCompChess, false, false);

                    // 调整计数
                    DOM.regretCount.textContent = --state.regretCount;

                    // 恢复落子
                    const {playerMove, computerMove} = state.moveHistory;
                    state.chessBoard[playerMove.i][playerMove.j] = 1;
                    state.chessBoard[computerMove.i][computerMove.j] = 2;

                    // 恢复赢法状态
                    state.myWin = [...state.moveHistory.preMyWin];
                    state.computerWin = [...state.moveHistory.preCompWin];
                    checkWin(playerMove.i, playerMove.j, true, true);
                    const compWin = checkWin(computerMove.i, computerMove.j, false, true);

                    // 更新标记
                    state.lastPlayerChess = [playerMove.i, playerMove.j];
                    state.lastCompChess = [computerMove.i, computerMove.j];
                    redrawPiece(playerMove.i, playerMove.j, true, true);
                    redrawPiece(computerMove.i, computerMove.j, false, true);

                    // 检查胜利状态
                    const playerWin = checkRestoredWin(true);
                    if (playerWin) {
                        DOM.resultWrap.innerHTML = '很厉害，你赢了！';
                        state.over = true;
                        state.winner = 'player';
                        state.canBack = false;
                    } else if (compWin) {
                        DOM.resultWrap.innerHTML = '很遗憾，你输了！';
                        state.over = true;
                        state.winner = 'computer';
                    }

                    // 更新状态
                    Object.assign(state, {
                        canReturn: false,
                        canBack: true,
                        isPlayerTurn: !compWin && !playerWin,
                        isCompWinRegret: false,
                        hasCountLose: false
                    });
                    updateBtnStates();
                };
            }

            // 5. 简化游戏状态重置
            function resetGameState() {
                Object.assign(state, {
                    over: false,
                    isPlayerTurn: true,
                    canBack: false,
                    canReturn: false,
                    playerMove: null,
                    computerMove: null,
                    moveHistory: null,
                    isCompWinRegret: false,
                    hasCountLose: false,
                    lastPlayerChess: null,
                    lastCompChess: null,
                    winLine: [],
                    winColor: null,
                    winner: null,
                    regretCount: 0,
                    loseCount: 0
                });
                DOM.resultWrap.innerHTML = '单机五子棋';
                DOM.regretCount.textContent = '0';
                DOM.loseCount.textContent = '0';
                initBoard();
                drawChessBoard();
                updateBtnStates();
            }

            // 6. 简化棋盘初始化（保留原赢法逻辑）
            function initBoard() {
                const {boardSize} = state;
                state.chessBoard = Array.from({length: boardSize}, () => new Array(boardSize).fill(0));
                state.wins = Array.from({length: boardSize}, () => Array.from({length: boardSize}, () => []));
                state.winCount = 0;
                const maxPos = boardSize - 5;

                // 横线赢法
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j <= maxPos; j++) {
                        for (let k = 0; k < 5; k++) state.wins[i][j + k].push(state.winCount);
                        state.winCount++;
                    }
                }

                // 竖线赢法
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j <= maxPos; j++) {
                        for (let k = 0; k < 5; k++) state.wins[j + k][i].push(state.winCount);
                        state.winCount++;
                    }
                }

                // 正斜线赢法
                for (let i = 0; i <= maxPos; i++) {
                    for (let j = 0; j <= maxPos; j++) {
                        for (let k = 0; k < 5; k++) state.wins[i + k][j + k].push(state.winCount);
                        state.winCount++;
                    }
                }

                // 反斜线赢法
                for (let i = 0; i <= maxPos; i++) {
                    for (let j = boardSize - 1; j >= 4; j--) {
                        for (let k = 0; k < 5; k++) state.wins[i + k][j - k].push(state.winCount);
                        state.winCount++;
                    }
                }

                state.myWin = new Array(state.winCount).fill(0);
                state.computerWin = new Array(state.winCount).fill(0);
            }

            // 7. 优化AI落子（保留原分数算法）
            function computerAI() {
                if (state.isPlayerTurn || state.over || state.winner) return;

                const {boardSize, chessBoard, wins, myWin, computerWin} = state;
                const myScore = Array.from({length: boardSize}, () => new Array(boardSize).fill(0));
                const compScore = Array.from({length: boardSize}, () => new Array(boardSize).fill(0));
                let [maxScore, u, v] = [0, 0, 0];

                // 计算最优落子
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (chessBoard[i][j] === 0) {
                            // 玩家分数（防御）
                            wins[i][j].forEach(k => {
                                myScore[i][j] += myWin[k] === 1 ? 200 : myWin[k] === 2 ? 400 : myWin[k] === 3 ? 2000 : myWin[k] === 4 ? 10000 : 0;
                            });
                            // 电脑分数（进攻）
                            wins[i][j].forEach(k => {
                                compScore[i][j] += computerWin[k] === 1 ? 220 : computerWin[k] === 2 ? 420 : computerWin[k] === 3 ? 2100 : computerWin[k] === 4 ? 20000 : 0;
                            });
                            // 选择最优位置
                            if (myScore[i][j] > maxScore || (myScore[i][j] === maxScore && compScore[i][j] > compScore[u][v])) {
                                maxScore = myScore[i][j];
                                [u, v] = [i, j];
                            }
                            if (compScore[i][j] > maxScore || (compScore[i][j] === maxScore && myScore[i][j] > myScore[u][v])) {
                                maxScore = compScore[i][j];
                                [u, v] = [i, j];
                            }
                        }
                    }
                }

                // 清除上一电脑棋子标记
                state.lastCompChess && redrawPiece(...state.lastCompChess, false, false);
                // 执行落子
                state.computerMove = {i: u, j: v};
                chessBoard[u][v] = 2;
                redrawPiece(u, v, false, true);
                state.lastCompChess = [u, v];

                // 检查电脑胜利
                if (checkWin(u, v, false)) {
                    DOM.resultWrap.innerHTML = '很遗憾，你输了！';
                    state.over = true;
                    state.winner = 'computer';
                    state.hasCountLose = false;
                    return;
                }

                // 检查和棋
                if (checkDraw()) {
                    DOM.resultWrap.innerHTML = '棋盘已满，和棋！';
                    state.over = true;
                    state.winner = 'draw';
                    state.canBack = state.canReturn = false;
                    updateBtnStates();
                    return;
                }

                // 切换回玩家回合
                state.isPlayerTurn = true;
            }

            // 8. 简化棋盘绘制
            function drawChessBoard() {
                const {width, height} = DOM.chess;
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#bfbfbf';
                ctx.lineWidth = 1;
                for (let i = 0; i < state.boardSize; i++) {
                    // 竖线
                    ctx.beginPath();
                    ctx.moveTo(15 + i * 30, 15);
                    ctx.lineTo(15 + i * 30, height - 15);
                    ctx.stroke();
                    // 横线
                    ctx.beginPath();
                    ctx.moveTo(15, 15 + i * 30);
                    ctx.lineTo(width - 15, 15 + i * 30);
                    ctx.stroke();
                }
            }

            // 9. 简化最新棋子更新
            function updateLatestPieces() {
                state.lastPlayerChess = null;
                state.lastCompChess = null;
                const {boardSize, chessBoard} = state;
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (chessBoard[i][j] === 1) state.lastPlayerChess = [i, j];
                        else if (chessBoard[i][j] === 2) state.lastCompChess = [i, j];
                    }
                }
            }

            // 10. 保留原棋子样式，简化绘制逻辑
            function redrawAllPieces() {
                const {boardSize, chessBoard, lastPlayerChess, lastCompChess} = state;
                // 绘制最新棋子
                lastPlayerChess && redrawPiece(...lastPlayerChess, true, false);
                lastCompChess && redrawPiece(...lastCompChess, false, false);
                // 绘制所有棋子
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (chessBoard[i][j] === 1) {
                            const isLast = lastPlayerChess && i === lastPlayerChess[0] && j === lastPlayerChess[1];
                            redrawPiece(i, j, true, isLast);
                        } else if (chessBoard[i][j] === 2) {
                            const isLast = lastCompChess && i === lastCompChess[0] && j === lastCompChess[1];
                            redrawPiece(i, j, false, isLast);
                        }
                    }
                }
            }

            // 核心棋子绘制（样式完全保留）
            function redrawPiece(i, j, isPlayer, drawMark) {
                const x = 15 + i * 30;
                const y = 15 + j * 30;
                const r = 13;
                // 清除区域
                ctx.clearRect(x - r - 3, y - r - 3, r * 2 + 6, r * 2 + 6);
                // 绘制棋子
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.closePath();
                const gradient = ctx.createRadialGradient(x + 2, y - 2, r, x + 2, y - 2, 0);
                if (isPlayer) {
                    gradient.addColorStop(0, '#0a0a0a');
                    gradient.addColorStop(1, '#636766');
                } else {
                    gradient.addColorStop(0, '#d1d1d1');
                    gradient.addColorStop(1, '#f9f9f9');
                }
                ctx.fillStyle = gradient;
                ctx.fill();
                // 绘制标记（样式不变）
                if (drawMark) {
                    const color = isPlayer ? '#00ff00' : '#ff0000';
                    drawCornerMark(i, j, color);
                }
            }

            // 棋子角标记（样式完全保留）
            function drawCornerMark(i, j, color) {
                const x = 15 + i * 30;
                const y = 15 + j * 30;
                const r = 13;
                const segment = (r * 2) / 3;
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                // 上边缘
                ctx.beginPath();
                ctx.moveTo(x - r, y - r);
                ctx.lineTo(x - r + segment, y - r);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + r - segment, y - r);
                ctx.lineTo(x + r, y - r);
                ctx.stroke();

                // 下边缘
                ctx.beginPath();
                ctx.moveTo(x - r, y + r);
                ctx.lineTo(x - r + segment, y + r);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + r - segment, y + r);
                ctx.lineTo(x + r, y + r);
                ctx.stroke();

                // 左边缘
                ctx.beginPath();
                ctx.moveTo(x - r, y - r);
                ctx.lineTo(x - r, y - r + segment);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x - r, y + r - segment);
                ctx.lineTo(x - r, y + r);
                ctx.stroke();

                // 右边缘
                ctx.beginPath();
                ctx.moveTo(x + r, y - r);
                ctx.lineTo(x + r, y - r + segment);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + r, y + r - segment);
                ctx.lineTo(x + r, y + r);
                ctx.stroke();

                ctx.restore();
            }

            // 11. 简化胜利检查
            function checkWin(i, j, isPlayer, force = false) {
                const winArr = isPlayer ? state.myWin : state.computerWin;
                for (const k of state.wins[i][j]) {
                    if (!force) {
                        winArr[k]++;
                        isPlayer ? state.computerWin[k] = 6 : state.myWin[k] = 6;
                    }
                    if (winArr[k] === 5) {
                        collectWinLine(k);
                        generateWinColor();
                        drawWinLine(state.winLine, state.winColor);
                        return true;
                    }
                }
                return false;
            }

            // 撤销时胜利检查
            function checkRestoredWin(isPlayer) {
                const winArr = isPlayer ? state.myWin : state.computerWin;
                for (let k = 0; k < state.winCount; k++) {
                    if (winArr[k] === 5) {
                        collectWinLine(k);
                        generateWinColor();
                        drawWinLine(state.winLine, state.winColor);
                        return true;
                    }
                }
                return false;
            }

            // 收集胜利连线
            function collectWinLine(winKey) {
                state.winLine = [];
                const {boardSize, wins} = state;
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        wins[i][j].includes(winKey) && state.winLine.push([i, j]);
                    }
                }
            }

            // 生成胜利线颜色
            function generateWinColor() {
                const colors = ['#ff3366', '#3366ff', '#33cc99', '#ffcc00', '#cc66ff', '#ff6666', '#66ccff', '#9966ff'];
                const startIdx = Math.floor(Math.random() * colors.length);
                state.winColor = [colors[startIdx], colors[startIdx].replace('ff', '44')];
            }

            // 绘制胜利线
            function drawWinLine(line, [startColor, endColor]) {
                if (line.length !== 5) return;
                ctx.save();
                const startX = 15 + line[0][0] * 30;
                const startY = 15 + line[0][1] * 30;
                const endX = 15 + line[4][0] * 30;
                const endY = 15 + line[4][1] * 30;
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                line.slice(1).forEach(([i, j]) => ctx.lineTo(15 + i * 30, 15 + j * 30));
                ctx.stroke();
                ctx.restore();
            }

            // 和棋判断
            function checkDraw() {
                const {boardSize, chessBoard} = state;
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (chessBoard[i][j] === 0) return false;
                    }
                }
                return true;
            }
        </script>
    </body>
</html>
