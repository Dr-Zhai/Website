<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8"/>
        <title>单机五子棋</title>
        <style>
            body {
                /* 优先使用微软雅黑（中英文名称都写上，兼容不同环境），最后 fallback 到无衬线字体 */
                font-family: "Microsoft YaHei", "微软雅黑", sans-serif;
            }

            canvas {
                display: block;
                margin: 20px auto;
                box-shadow: -2px -2px 2px #efefef, 5px 5px 5px #b9b9b9;
                cursor: pointer;
            }

            .board-select {
                text-align: center;
                margin: 20px 0;
            }

            .board-select span {
                display: inline-block;
                padding: 8px 16px;
                margin: 0 5px;
                background: #4CAF50;
                color: #fff;
                border-radius: 4px;
                cursor: pointer;
            }

            .board-select span.active {
                background: #388E3C;
            }

            .btn-wrap {
                display: flex;
                justify-content: center;
                margin: 10px 0;
            }

            .btn-wrap div {
                margin: 0 10px;
            }

            div > span {
                display: inline-block;
                padding: 10px 20px;
                color: #fff;
                background: #4CAF50;
                border-radius: 5px;
                cursor: pointer;
            }

            div.unable span {
                background: #A9A9A9;
                color: #666;
                cursor: not-allowed;
            }

            #result-wrap {
                text-align: center;
                margin: 30px 0;
            }

            .copyright {
                text-align: center;
                margin: 30px 0;
                color: #666;
                font-size: 14px;
            }
        </style>
    </head>
    <body>
        <h1 id="result-wrap">单机五子棋</h1>

        <div class="board-select">
            <b>棋盘大小：</b>
            <span class="board-size" data-size="15">标准棋盘(15x15)</span>
            <span class="board-size" data-size="30">超大棋盘(30x30)</span>
        </div>

        <canvas height="450" id="chess" width="450"></canvas>

        <div class="btn-wrap">
            <div class="restart" id='restart'><span>重新开始</span></div>
            <div class="goback unable" id='goback'><span>悔棋</span></div>
            <div class="return unable" id='return'><span>撤销</span></div>
            <div class="sponsor" id='sponsor'><span>赞助支持</span></div>
        </div>

        <footer class="copyright">© <span id="currentYear"></span> 宅博士. 版权所有.</footer>

        <script>
            // 核心状态变量
            let over = false, me = true;
            let [_nowi, _nowj, _compi, _compj] = [0, 0, 0, 0];
            let [_myWin, _compWin] = [[], []];
            let [backAble, returnAble] = [false, false];
            let resultTxt = document.getElementById('result-wrap');
            let [chressBord, myWin, computerWin, wins] = [[], [], [], []];
            let count = 0, boardSize = 15;
            let chess = document.getElementById("chess");
            let context = chess.getContext('2d');
            let [backbtn, returnbtn] = [document.getElementById('goback'), document.getElementById('return')];

            // 初始化年份
            document.getElementById("currentYear").textContent = new Date().getFullYear();

            // 页面加载初始化
            window.onload = () => {
                initBoard();
                drawChessBoard();
                bindEvents();
            };

            // 统一绑定事件
            function bindEvents() {
                // 棋盘大小选择
                document.querySelectorAll('.board-size').forEach(btn => {
                    btn.addEventListener('click', function () {
                        if (over) return;
                        document.querySelectorAll('.board-size').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        boardSize = parseInt(this.dataset.size);
                        chess.width = chess.height = boardSize * 30;
                        initBoard();
                        drawChessBoard();
                        resetGameState();
                    });
                });
                document.querySelector('[data-size="15"]').classList.add('active');

                // 赞助按钮
                document.getElementById("sponsor").onclick = () => window.open("payment/pay.html", "_blank");

                // 重新开始
                document.getElementById("restart").onclick = () => window.location.reload();

                // 玩家下棋
                chess.onclick = e => {
                    if (over || !me) return;
                    backbtn.classList.remove('unable');
                    const i = Math.floor(e.offsetX / 30), j = Math.floor(e.offsetY / 30);
                    [_nowi, _nowj] = [i, j];
                    if (chressBord[i][j] === 0) {
                        oneStep(i, j, me);
                        chressBord[i][j] = 1;
                        // 检查胜利
                        let win = false;
                        for (let k = 0; k < count; k++) {
                            if (wins[i][j][k]) {
                                myWin[k]++;
                                _compWin[k] = computerWin[k];
                                computerWin[k] = 6;
                                if (myWin[k] === 5) {
                                    resultTxt.innerHTML = '恭喜，你赢了！';
                                    over = win = true;
                                    break;
                                }
                            }
                        }
                        if (!win) {
                            me = false;
                            setTimeout(computerAI, 500); // 延迟500ms落子
                        }
                    }
                };

                // 悔棋
                backbtn.onclick = () => {
                    if (!backAble || over) return;
                    over = false;
                    me = true;
                    returnbtn.classList.remove('unable');
                    // 玩家悔棋
                    chressBord[_nowi][_nowj] = 0;
                    minusStep(_nowi, _nowj);
                    for (let k = 0; k < count; k++) {
                        if (wins[_nowi][_nowj][k]) {
                            myWin[k]--;
                            computerWin[k] = _compWin[k];
                        }
                    }
                    // 计算机悔棋
                    chressBord[_compi][_compj] = 0;
                    minusStep(_compi, _compj);
                    for (let k = 0; k < count; k++) {
                        if (wins[_compi][_compj][k]) {
                            computerWin[k]--;
                            myWin[k] = _myWin[k];
                        }
                    }
                    resultTxt.innerHTML = '单机五子棋';
                    [returnAble, backAble] = [true, false];
                    backbtn.classList.add('unable');
                };

                // 撤销悔棋
                returnbtn.onclick = () => {
                    if (!returnAble || over) return;
                    // 玩家撤销悔棋
                    chressBord[_nowi][_nowj] = 1;
                    oneStep(_nowi, _nowj, me);
                    let win = false;
                    for (let k = 0; k < count; k++) {
                        if (wins[_nowi][_nowj][k]) {
                            myWin[k]++;
                            _compWin[k] = computerWin[k];
                            computerWin[k] = 6;
                            if (myWin[k] === 5) {
                                resultTxt.innerHTML = '恭喜，你赢了！';
                                over = win = true;
                                break;
                            }
                        }
                    }
                    // 计算机撤销悔棋（玩家未胜时）
                    if (!win) {
                        chressBord[_compi][_compj] = 2;
                        oneStep(_compi, _compj, false);
                        for (let k = 0; k < count; k++) {
                            if (wins[_compi][_compj][k]) {
                                computerWin[k]++;
                                _myWin[k] = myWin[k];
                                myWin[k] = 6;
                                if (computerWin[k] === 5) {
                                    resultTxt.innerHTML = '计算机赢了，继续加油哦！';
                                    over = true;
                                    break;
                                }
                            }
                        }
                    }
                    returnbtn.classList.add('unable');
                    [returnAble, backAble] = [false, true];
                    backbtn.classList.remove('unable');
                    if (win) me = false;
                    else if (!over) me = !me;
                };
            }

            // 重置游戏状态
            function resetGameState() {
                over = false;
                me = true;
                [backAble, returnAble] = [false, false];
                backbtn.classList.add('unable');
                returnbtn.classList.add('unable');
                resultTxt.innerHTML = '单机五子棋';
            }

            // 初始化棋盘数据
            function initBoard() {
                [chressBord, wins, myWin, computerWin, _myWin, _compWin] = [[], [], [], [], [], []];
                count = 0;
                // 初始化棋盘和赢法数组
                for (let i = 0; i < boardSize; i++) {
                    chressBord[i] = new Array(boardSize).fill(0);
                    wins[i] = Array.from({length: boardSize}, () => []);
                }
                const winLineLen = 5, maxJ = boardSize - winLineLen;
                // 横线赢法
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j <= maxJ; j++) {
                        for (let k = 0; k < winLineLen; k++) wins[i][j + k][count] = true;
                        count++;
                    }
                }
                // 竖线赢法
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j <= maxJ; j++) {
                        for (let k = 0; k < winLineLen; k++) wins[j + k][i][count] = true;
                        count++;
                    }
                }
                // 正斜线赢法
                for (let i = 0; i <= maxJ; i++) {
                    for (let j = 0; j <= maxJ; j++) {
                        for (let k = 0; k < winLineLen; k++) wins[i + k][j + k][count] = true;
                        count++;
                    }
                }
                // 反斜线赢法
                for (let i = 0; i <= maxJ; i++) {
                    for (let j = boardSize - 1; j >= winLineLen - 1; j--) {
                        for (let k = 0; k < winLineLen; k++) wins[i + k][j - k][count] = true;
                        count++;
                    }
                }
                // 初始化赢法统计
                for (let i = 0; i < count; i++) {
                    [myWin[i], _myWin[i], computerWin[i], _compWin[i]] = [0, 0, 0, 0];
                }
            }

            // 计算机AI
            function computerAI() {
                if (over) return;
                let [myScore, computerScore] = [[], []];
                let [max, u, v] = [0, 0, 0];
                // 初始化分数数组
                for (let i = 0; i < boardSize; i++) {
                    myScore[i] = new Array(boardSize).fill(0);
                    computerScore[i] = new Array(boardSize).fill(0);
                }
                // 计算分数
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (chressBord[i][j] === 0) {
                            for (let k = 0; k < count; k++) {
                                if (wins[i][j][k]) {
                                    // 玩家分数
                                    if (myWin[k] === 1) myScore[i][j] += 200;
                                    else if (myWin[k] === 2) myScore[i][j] += 400;
                                    else if (myWin[k] === 3) myScore[i][j] += 2000;
                                    else if (myWin[k] === 4) myScore[i][j] += 10000;
                                    // 计算机分数
                                    if (computerWin[k] === 1) computerScore[i][j] += 220;
                                    else if (computerWin[k] === 2) computerScore[i][j] += 420;
                                    else if (computerWin[k] === 3) computerScore[i][j] += 2100;
                                    else if (computerWin[k] === 4) computerScore[i][j] += 20000;
                                }
                            }
                            // 选择最优位置
                            if (myScore[i][j] > max || (myScore[i][j] === max && computerScore[i][j] > computerScore[u][v])) {
                                [max, u, v] = [myScore[i][j], i, j];
                            }
                            if (computerScore[i][j] > max || (computerScore[i][j] === max && myScore[i][j] > myScore[u][v])) {
                                [max, u, v] = [computerScore[i][j], i, j];
                            }
                        }
                    }
                }
                // 落子
                [_compi, _compj] = [u, v];
                oneStep(u, v, false);
                chressBord[u][v] = 2;
                // 检查胜利
                for (let k = 0; k < count; k++) {
                    if (wins[u][v][k]) {
                        computerWin[k]++;
                        _myWin[k] = myWin[k];
                        myWin[k] = 6;
                        if (computerWin[k] === 5) {
                            resultTxt.innerHTML = '计算机赢了，继续加油哦！';
                            over = true;
                            break;
                        }
                    }
                }
                if (!over) me = true;
                [backAble, returnAble] = [true, false];
                returnbtn.classList.add('unable');
            }

            // 绘制棋盘
            function drawChessBoard() {
                context.clearRect(0, 0, chess.width, chess.height);
                context.strokeStyle = '#bfbfbf';
                for (let i = 0; i < boardSize; i++) {
                    context.moveTo(15 + i * 30, 15);
                    context.lineTo(15 + i * 30, chess.height - 15);
                    context.stroke();
                    context.moveTo(15, 15 + i * 30);
                    context.lineTo(chess.width - 15, 15 + i * 30);
                    context.stroke();
                }
            }

            // 绘制棋子（带动画）
            function oneStep(i, j, isMe) {
                const [centerX, centerY, radius] = [15 + i * 30, 15 + j * 30, 13];
                let [alpha, scale] = [0, 0.3];

                function animate() {
                    context.save();
                    context.clearRect(centerX - radius - 2, centerY - radius - 2, radius * 2 + 4, radius * 2 + 4);
                    context.beginPath();
                    context.arc(centerX, centerY, radius * scale, 0, 2 * Math.PI);
                    context.closePath();
                    // 棋子渐变
                    const gradient = context.createRadialGradient(
                        centerX + 2, centerY - 2, radius * scale,
                        centerX + 2, centerY - 2, 0
                    );
                    if (isMe) {
                        gradient.addColorStop(0, '#0a0a0a');
                        gradient.addColorStop(1, '#636766');
                    } else {
                        gradient.addColorStop(0, '#d1d1d1');
                        gradient.addColorStop(1, '#f9f9f9');
                    }
                    context.fillStyle = gradient;
                    context.globalAlpha = alpha;
                    context.fill();
                    context.restore();
                    // 动画更新
                    alpha += 0.2;
                    scale += 0.14;
                    if (alpha < 1) requestAnimationFrame(animate);
                }

                animate();
            }

            // 移除棋子（重绘棋盘线时使用当前棋盘颜色）
            function minusStep(i, j) {
                const [x, y] = [i * 30, j * 30];
                context.clearRect(x, y, 30, 30);
                // 重绘被擦除的线（使用当前棋盘颜色#888）
                context.beginPath();
                context.moveTo(15 + i * 30, y);
                context.lineTo(15 + i * 30, y + 30);
                context.moveTo(x, 15 + j * 30);
                context.lineTo(x + 30, 15 + j * 30);
                context.stroke();
            }
        </script>
    </body>
</html>
